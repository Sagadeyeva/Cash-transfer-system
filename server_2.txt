#include <iostream>
#pragma comment(lib,"Ws2_32.lib")
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <thread>
#include <mutex>
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include <algorithm>
#include <locale>
#include <ctype.h>

#define MAX_CLIENTS 10

using namespace std;
HANDLE hMutex;
std::mutex consoleMutex;
long int threadID;
int amount_of_clients;

struct Arggs {
    SOCKET sock;
    std::thread *Th;
    sockaddr_in info;
    int id;
    boolean closure;
};

struct wallet {
    string walletID;
    int value;
};

struct transfer_data {
    string wallet_from;
    string login;
    string wallet_to;
    int amount;
};
std::vector <Arggs *>list_of_clients;

void startWSA(){
    WSADATA wsaDATA;
    int iResult=WSAStartup(MAKEWORD(2,2), &wsaDATA);
    if(iResult!=0){
        printf("WSAStartup failed with error: %d\n", iResult);
        exit(1);
    }else
        puts("WSAStartup success");
}


int readn(SOCKET Sock, char *pBuffer, int Size) {
    while (Size)
    {
        int const nBytes=recv (Sock, pBuffer, Size, 0);
                if (recv (Sock, pBuffer, Size, 0)==SOCKET_ERROR) {
                    return SOCKET_ERROR;
                }

              if ((0==nBytes)||(-1==nBytes))
                {
                    return -1;
                }
                pBuffer +=nBytes;
                Size -= nBytes;
    }
    return 0;
}

string to_upper(string input) {
    transform(input.begin(), input.end(), input.begin(), (int (*)(int))std::toupper);
    return input;
}

vector <string> split (string &s, char symbol) {
    stringstream ss(s);
    string elem;
    vector<string> letters;
    while (getline(ss, elem, symbol))
        letters.push_back(elem);
    return letters;
}

vector <transfer_data> get_receives(string user_input){
    WaitForSingleObject(hMutex,INFINITE);
    vector<transfer_data>tr;
    ifstream ifs;
    stringstream ss;
    ss<<"C:/receive.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path,str.c_str());
    ifs.open(path);
    string line;
        if(ifs.is_open()){
        while(getline(ifs,line)){
            vector<string> tempStrings=split(line,' ');
            transfer_data transmission;
            transmission.wallet_from=tempStrings[0];
            transmission.login=tempStrings[1];
            transmission.wallet_to=tempStrings[2];
            transmission.amount=atoi(tempStrings[3].c_str());
            tr.insert(tr.end(),transmission);
        }
    }else{
        consoleMutex.lock();
        cout<<"Error. Can not open the file"<<endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
    return tr;
}
vector<transfer_data> get_sends(string inputLogin){
    WaitForSingleObject(hMutex,INFINITE);
    vector<transfer_data>sends;
    ifstream ifs;
    stringstream ss;
    ss<<"C:/sends.txt";
    string str=ss.str();

    char *path=new char[str.length()+1];
    strcpy(path,str.c_str());
    ifs.open(path);
    string line;
        if(ifs.is_open()){
        while(getline(ifs,line)){
            vector<string> tempStrings=split(line,' ');
            transfer_data transmission;
            transmission.wallet_from=tempStrings[0];
            transmission.login=tempStrings[1];
            transmission.wallet_to=tempStrings[2];
            transmission.amount=atoi(tempStrings[3].c_str());
            sends.insert(sends.end(),transmission);
        }
    }else{
        consoleMutex.lock();
        cout<<"Error. Can not open the file"<<endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
    return sends;
}

vector <wallet> get_wallets(string user_input) {
    WaitForSingleObject(hMutex, INFINITE);
    vector <wallet> wallets;
    stringstream ss;
   ifstream fs;
    ss<<user_input;
    string str=ss.str();
    fs.open("C:/wallets.txt");
    string line;
    if (fs.is_open()) {
        while (getline(fs,line)) {
            vector <string> tempStrings=split(line, ' ');
            wallet wally;
            wally.walletID=tempStrings[0];
            wally.value=atoi(tempStrings[1].c_str());
            wallets.insert(wallets.end(), wally);
            }
    }
    else {
        consoleMutex.lock();
        cout<<"Can`t open the file"<<endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
 return wallets;
}

void rewriteData (string user_input, vector <wallet> wallets_to_rewrite) {
    WaitForSingleObject(hMutex,INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<user_input;
    string str=ss.str();
    fs.open("C:/wallets.txt");
    if (fs.is_open()) {
        for (int i=0; i<wallets_to_rewrite.size(); i++) {
            fs<<wallets_to_rewrite[i].walletID<<" "<<wallets_to_rewrite[i].value<<endl;
        }
    }
    else {
        consoleMutex.lock();
        cout<<"Can`t open the file"<<endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
    fs.close();
}

int money_addition (string user_input, string wallet_to_rewrite, int sum) {
    vector <wallet> wallet=get_wallets(user_input);
    for (int i=0; i<wallet.size(); i++) {
        if (wallet[i].walletID==wallet_to_rewrite) {
                wallet[i].value+=sum;
                rewriteData(user_input, wallet);
                return 1;
            }
        }
    return 0;
}

int receive_money (string user_input, string wallet_to_rewrite, int sum) {
    vector <wallet> wallet=get_wallets(user_input);
    for (int i=0; i<wallet.size(); i++) {
        if (wallet[i].walletID==wallet_to_rewrite) {
                if (wallet[i].value<sum) {
                    return -1;
                }
                wallet[i].value-=sum;
                rewriteData(user_input, wallet);
                return 1;
            }
        }
    return 0;
}

void newSend (string fromUser, string sendWallet, string toUser, string recieveWallet, int sum) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<"C:/sends.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    fs.open(path, ofstream::app);
    if (fs.is_open()) {
        fs<<sendWallet<<" "<<toUser<<" "<<recieveWallet<<" "<<sum<<endl;
    }
    else {
        consoleMutex.lock();
        cout<<"Error. Can not open the file"<<endl;
    consoleMutex.unlock();
    }
    fs.close();
    ReleaseMutex(hMutex);
}

void newReceive(string toUser, string receiveWallet, string fromUser, string sendWallet, int sum) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<"C:/receive.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    fs.open(path, ofstream::app);

    if (fs.is_open()) {
        fs<<receiveWallet<<" "<<fromUser<<" "<<sendWallet<<" "<<sum<<endl;
    }
    else{
        consoleMutex.unlock();
        cout<<"Can not open the file"<<endl;
    }
    fs.close();
    ReleaseMutex(hMutex);
}

void rewriteSends (string user_input, vector <transfer_data> tr) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<"C:/sends.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    fs.open(path, ofstream::app);
    if (fs.is_open()) {
        for (int i=0; i<tr.size(); i++) {
            fs<<tr[i].wallet_from<<" "<<tr[i].wallet_to<<" "<<tr[i].amount<<endl;
        }
    }
    else  {
        consoleMutex.lock();
        cout<<"Error. Can not open the file!"<< endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
    fs.close();
}

void rewriteRecieves (string user_input, vector <transfer_data> tr) {

    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<"C:/receive.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    fs.open(path, ofstream::app);
    if (fs.is_open()) {
        for (int i=0; i<tr.size(); i++) {
            fs<<tr[i].wallet_from<<" "<<tr[i].wallet_to<<" "<<tr[i].amount<<endl;
        }
    }
    else  {
        consoleMutex.lock();
        cout<<"Error. Can not open the file!"<< endl;
        consoleMutex.unlock();
    }
    ReleaseMutex(hMutex);
    fs.close();
}

int sendSum (string fromUser, string fromWallet, string toUser, string toWallet, int sum) {
    vector <wallet> fromWallets=get_wallets(fromUser);
    vector <wallet> toWallets =get_wallets(toUser);
    for (int i=0; i<fromWallets.size(); i++) {
        for (int j=0; j<toWallets.size(); j++) {
            if ((fromWallets[i].walletID==fromWallet) && (toWallets[j].walletID==toWallet)) {
                if (receive_money(fromUser, fromWallet, sum)==1) {
                    newSend(fromUser, fromWallet, toUser, toWallet, sum);
                    newReceive(toUser, toWallet, fromUser, fromWallet, sum);
                        return 1;
                    }
                    else{
                            return 3;
                    }
                    }else{
                            return 2;
                    }
                }

                }


                return 0;

}

void receiveSum (string user_input, string userWallet, string to_User, string toWallet, int sum) {
    vector <transfer_data> tr=get_receives(user_input);
    vector <transfer_data> updatedReceives;

    for (int i=0; i<tr.size(); i++) {
        if ((tr[i].wallet_from==userWallet) &&
            (tr[i].wallet_to==toWallet) &&
            (tr[i].amount==sum)
        ) {
            money_addition(user_input, userWallet, sum);
        } else {
            updatedReceives.insert(updatedReceives.end(), tr[i]);
        }
    }
    rewriteRecieves(user_input, updatedReceives);

    tr=get_sends(user_input);
    vector <transfer_data> updatedSends;
    for (int i=0; i<tr.size(); i++) {
        if  ((tr[i].wallet_from==userWallet) &&
            (tr[i].wallet_to==toWallet) &&
            (tr[i].amount==sum)
        ) {
            receive_money(user_input, toWallet, sum);
        }
        else {
            updatedSends.insert(updatedSends.end(), tr[i]);
        }
    }
    rewriteSends(to_User, updatedSends);
}

int addWalet (string user_input, string walletID) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    stringstream ss;
    ss<<"C:/wallets.txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    fs.open(path, ofstream::app);
    if (fs.is_open()) {
            fs<<walletID<<" "<<"0"<<endl;
            fs.close();
            return 1;
    } else {
        cout<<"Error can not open the file!"<<endl;
        return -1;
    }
    fs.close();
    ReleaseMutex(hMutex);
    return 0;
}

int addUser(string login, string password) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream fs;
    fs.open("C:/users.txt", ofstream::app);
    if (fs.is_open()) {
        fs<<login<<" "<<password<<endl;
        fs.close();
        return 1;}
        else {
            consoleMutex.lock();
            cout<<"Error, can not open the file!"<<endl;
            consoleMutex.unlock();
            return -1;
        }
        ReleaseMutex(hMutex);
        return 0;
}

int login(string login, string password) {
    WaitForSingleObject(hMutex, INFINITE);
    ifstream ifs;
    ifs.open("C:/users.txt");
    string tempL, tempP;
    if (ifs.is_open()) {
            while (!ifs.eof()){
        ifs>>tempL>>tempP;
        if ((login==tempL) && (password==tempP)) {
            return 1;
        }
    }
    }
    else {
        consoleMutex.lock();
        cout<<"Error, can not open the file!"<<endl;
        consoleMutex.unlock();
        return -1;
    }
    ifs.close();
    ReleaseMutex(hMutex);
    return 0;
}

int login_check (string login) {
    WaitForSingleObject(hMutex, INFINITE);
    ifstream ifs;
    ifs.open("C:/users.txt");
    string tempL, tempP;
    if (ifs.is_open()) {
        while (!ifs.eof()) {
            ifs>>tempL>>tempP;
            if (login==tempL) {
                ReleaseMutex(hMutex);
                return 1;
            }
        }
    }
    else {
        consoleMutex.lock();
        cout<<"Error, can not open the file!"<<endl;
        consoleMutex.unlock();
        ReleaseMutex(hMutex);
        return -1;
    }
    return 0;
}

int closeClient(int ind) {
    WaitForSingleObject(hMutex, INFINITE);
    int disc_index=-1;
    for (int i=0; i<list_of_clients.size(); i++)
    {
        if (list_of_clients[i]->id==ind)
            {disc_index=i;
           ReleaseMutex(hMutex);
            break;
            }
    }
    if (disc_index>=0) {
        list_of_clients[disc_index]->closure=true;
        int disconnecter=ind;
        if (!disconnecter) {
            printf("Socket has not been closed!\n");
            ReleaseMutex(hMutex);
            return -1;
        }
        else {
            printf("\n Client with ID %d has been disconnected \n",ind);
            amount_of_clients--;
            ReleaseMutex(hMutex);
        }
        delete(list_of_clients[disc_index]);
        list_of_clients.erase(list_of_clients.begin()+disc_index);
    }
    ReleaseMutex(hMutex);
    return 0;
}

int UserInfo (string in_login) {
    WaitForSingleObject(hMutex, INFINITE);
    ofstream ofs;
    stringstream ss;
    ss<<"C:\\tcpServer\\"<<in_login<<".txt";
    string str=ss.str();
    char *path=new char[str.length()+1];
    strcpy(path, str.c_str());
    ofs.open(path, ofstream::app);
    if (ofs.is_open()) {
    ofs<<"start_online_wallets"<<endl<<"end_online_wallets"<<endl<<"start_requests"<<endl<<
                "end_requests"<<endl<<"start_sends"<<endl<<"end_sends"<<endl;
        ofs.close();
    }
    else {
        cout<<"Error. Can not open file"<<endl;
        return -1;
    }
    ReleaseMutex(hMutex);
    }

int sender(SOCKET s, char* buffer, int buflen){
            int res=send(s,buffer,buflen,0);
            if(res<=0)
                return 0;
            return 1;
}

int client_thread (Arggs * c) {
    char buffer[512];
    SOCKET s=c->sock;
    memset(buffer,0,sizeof(buffer));
    int ires;
    char welcome[512]="Welcome to the cash-transfer system!\n Use the following form to sign in or register:\n LOGIN user password\n REGISTER user password\n";
    send(s, welcome, sizeof(welcome),0);

    int state=0;
    //string rez="";

    string username="";
    vector <wallet> wallets;
    vector <transfer_data> receives;
    vector <transfer_data> sends;
    std::vector <string> tempStr;
    while(true)
    {
            ires=readn(s,buffer,sizeof(buffer));
            send(s,buffer,sizeof(buffer),0);
            consoleMutex.lock();
            std::cout<<buffer<<std::endl;
            consoleMutex.unlock();
        if(ires==SOCKET_ERROR)
        {
                shutdown(s,2);
                closesocket(s);
                //closeClient(c->id);
                break;
        } else {
        std::string rez(buffer);
       // cout<<rez<<endl;
        if (count(rez.begin(), rez.end(), ' ')==2) {
         //  vector <string> tempStr=split(rez, ' ');
        // vector <string> tempStr::std;
         tempStr==split(rez, ' ');
        string com=to_upper(tempStr[0]);
        //com.compare("LOGIN");
            if (com.compare("LOGIN")==0) {
                if (login((string)tempStr[1], (string)tempStr[2])==1) {
                    consoleMutex.lock();
                    cout<<"Successful login.\n";
                    cout<<"You can use following commands:\n1) show_wallets\n2) show_sends\n3) create_wallet <walletName> \n4) show_receive\n5) put <wallet> <sum>\n6) get <wallet> <sum>\n7) send_money <toLogin> <toWallet> <sum>\n8) accept <wallet> <fromLogin> <fromWallet> <sum>\n";
                    consoleMutex.unlock();
                    state=1;
                } else {
                    consoleMutex.lock();
                    cout<<"Incorrect login";
                    consoleMutex.unlock();
                }
            } else
            if (com.compare("REGISTER")==0) {
                if (login_check(tempStr[1])==1) {
                    cout<<("Sorry, login has been already taken");
                } else {
                    cout<<("Successful authorization! Welcome:");
                    cout<<("You can use following commands:\n1) show_wallets\n2) show_sends\n3) create_wallet <walletName> \n4) show_receive\n5) put <wallet> <sum>\n6) get <wallet> <sum>\n7) send_money <toLogin> <toWallet> <sum>\n8) accept <wallet> <fromLogin> <fromWallet> <sum>\n");
                    username=tempStr[1];
                    state=1;
                }
            }
        cout<<tempStr[0];
        cout<<tempStr[1];
        cout<<tempStr[2];
       // cout<<rez;
        }
        else {
            cout<<("Sorry, but the form of your input is incorrect, try again...");
        }
    }

//break ???????
//case 1:
   // rez="";


    /*{
        ires=readn(s,buffer,sizeof(buffer));
        if(ires==SOCKET_ERROR)
        {
                shutdown(s,2);
                closesocket(s);
                closeClient(c->id);
                break;
        }
        consoleMutex.lock();
        printf("message----------> %s \n", buffer);
        consoleMutex.unlock();
        ires=send(s, buffer, sizeof(buffer), 0);
        consoleMutex.lock();
        printf("message recieved \n");
        consoleMutex.unlock();
        if (ires==SOCKET_ERROR)
            {
                shutdown(s,2);
                closesocket(s);
                break;
            }
    }
    */
    }
    return 0;
}

int acceptNewThread(SOCKET &s) {

    consoleMutex.lock();
    printf ("accepting\n");
    consoleMutex.unlock();
    int amount_of_clients;

    char buffer[512];
    char reciever[512];
    char sent_message[512];

while (1) {

   SOCKET newConnection;
    int iFamily = AF_INET;
   int iType = SOCK_STREAM;
   int iProtocol = IPPROTO_TCP;
   sockaddr_in clientAddress={0};
   int clientAddressLength=sizeof(clientAddress);
   newConnection = accept(s, (SOCKADDR *) & clientAddress, & clientAddressLength);
   amount_of_clients++;

   if (newConnection==INVALID_SOCKET) {
    break;
   }
  Arggs *new_client=new Arggs();
   new_client ->sock=newConnection;
   new_client ->id=newConnection;
   new_client->info=clientAddress;
   std::thread *threadd = new std::thread(client_thread,std::ref(new_client));
   new_client ->Th=threadd;
   WaitForSingleObject(hMutex, INFINITE);
   list_of_clients.push_back(new_client);
   ReleaseMutex(hMutex);
   printf("Client connected %s:%d \n",inet_ntoa(clientAddress.sin_addr),htons(clientAddress.sin_port));

}
for(Arggs * n : list_of_clients)
{
   shutdown(n->sock,2);
   closesocket(n->sock);
   n->Th->join();
   delete(n->Th);
   delete(n);
}
return 0;
}

void showClients()
{
    for(Arggs * n : list_of_clients)
{
     consoleMutex.lock();
     printf("ID: %d %s:%d\n", n->id, inet_ntoa(n->info.sin_addr),htons(n->info.sin_port));
     consoleMutex.unlock();
}
}

int main(void)
{
   WSADATA wsaData = {0};
   int ind;
   int res = 0;
   sockaddr_in server;
   res = WSAStartup(MAKEWORD(2, 2), &wsaData);
   SOCKET s = INVALID_SOCKET;
   int iFamily = AF_INET;
   int iType = SOCK_STREAM;
   int iProtocol = IPPROTO_TCP;
   s = socket(iFamily, iType, iProtocol);
   if (s==INVALID_SOCKET) {
        printf("failed");
        return -1;
   } else {
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr("192.168.136.1");
    server.sin_port = htons(27015);
    consoleMutex.lock();
    printf("Socket created\n");
    consoleMutex.unlock();
    if ((res = bind(s, (SOCKADDR *) &server, sizeof(server)))<0) {
        printf ("failed to bind \n");
        return -1;
    } else {
        consoleMutex.lock();
    printf ("connecting...\n");
    consoleMutex.unlock();
    }
    int client_to_delete=-1;

    res = listen(s,10);
    consoleMutex.lock();
    std::thread acceptThr(acceptNewThread, std::ref(s));
    consoleMutex.unlock();
    boolean closure=false;
    int comand;
    while (s!=INVALID_SOCKET) {
        int option=0;
        int ind;
        consoleMutex.lock();
            printf("1. Show all clients;\n");
            printf("2. Disconnect specific client;\n");
            printf("3. Add a new client;\n");
            printf("4. Show the state of a specific wallet;\n");
            printf("5. Make a cash transfer from client;\n");
            printf("6. Close server;\n");
consoleMutex.unlock();
consoleMutex.lock();
		printf("Your action:  \n");
consoleMutex.unlock();
		//scanf("%i \n", &option);
		std::cin>>option;

		switch (option) {
		case 1:{
                showClients();
                break;
                }
        case 2:{
            showClients();
            printf("Enter the ID of client to disconnect>>>>>>>> \n");
            std::cin>>ind;
            closeClient(ind);
            break;
        }


        case 6:
            {

   printf("Server is closing\n");
    shutdown(s,2);
    res = closesocket(s);
    acceptThr.join();
    printf("Server has been closed \n");
    return 0;
            }
    }
   }

}
return 0;
}
